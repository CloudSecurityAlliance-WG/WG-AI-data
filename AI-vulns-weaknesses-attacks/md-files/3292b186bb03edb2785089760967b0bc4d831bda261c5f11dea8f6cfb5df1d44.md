Towards Evaluating the Robustness
of Neural Networks
Nicholas Carlini David Wagner
University of California, Berkeley
ABSTRACT
Neural networks provide state-of-the-art results for most
machine learning tasks. Unfortunately, neural networks are
vulnerable to adversarial examples: given an input xand any
target classiÔ¨Åcation t, it is possible to Ô¨Ånd a new input x0
that is similar to xbut classiÔ¨Åed as t. This makes it difÔ¨Åcult
to apply neural networks in security-critical areas. Defensive
distillation is a recently proposed approach that can take an
arbitrary neural network, and increase its robustness, reducing
the success rate of current attacks‚Äô ability to Ô¨Ånd adversarial
examples from 95% to0:5%.
In this paper, we demonstrate that defensive distillation does
not signiÔ¨Åcantly increase the robustness of neural networks
by introducing three new attack algorithms that are successful
on both distilled and undistilled neural networks with 100%
probability. Our attacks are tailored to three distance metrics
used previously in the literature, and when compared to pre-
vious adversarial example generation algorithms, our attacks
are often much more effective (and never worse). Furthermore,
we propose using high-conÔ¨Ådence adversarial examples in
a simple transferability test we show can also be used to
break defensive distillation. We hope our attacks will be used
as a benchmark in future defense attempts to create neural
networks that resist adversarial examples.
I. I NTRODUCTION
Deep neural networks have become increasingly effective
at many difÔ¨Åcult machine-learning tasks. In the image recog-
nition domain, they are able to recognize images with near-
human accuracy [27], [25]. They are also used for speech
recognition [18], natural language processing [1], and playing
games [43], [32].
However, researchers have discovered that existing neural
networks are vulnerable to attack. Szegedy et al. [46] Ô¨Årst
noticed the existence of adversarial examples in the image
classiÔ¨Åcation domain: it is possible to transform an image by
a small amount and thereby change how the image is classiÔ¨Åed.
Often, the total amount of change required can be so small as
to be undetectable.
The degree to which attackers can Ô¨Ånd adversarial examples
limits the domains in which neural networks can be used.
For example, if we use neural networks in self-driving cars,
adversarial examples could allow an attacker to cause the car
to take unwanted actions.
The existence of adversarial examples has inspired research
on how to harden neural networks against these kinds ofOriginal Adversarial Original Adversarial
Fig. 1. An illustration of our attacks on a defensively distilled network.
The leftmost column contains the starting image. The next three columns
show adversarial examples generated by our L2,L1, andL0algorithms,
respectively. All images start out classiÔ¨Åed correctly with label l, and the three
misclassiÔ¨Åed instances share the same misclassiÔ¨Åed label of l+1 (mod 10) .
Images were chosen as the Ô¨Årst of their class from the test set.
attacks. Many early attempts to secure neural networks failed
or provided only marginal robustness improvements [15], [2],
[20], [42].
Defensive distillation [39] is one such recent defense pro-
posed for hardening neural networks against adversarial exam-
ples. Initial analysis proved to be very promising: defensive
distillation defeats existing attack algorithms and reduces their
success probability from 95% to0:5%. Defensive distillation
can be applied to any feed-forward neural network and only
requires a single re-training step, and is currently one of
the only defenses giving strong security guarantees against
adversarial examples.
In general, there are two different approaches one can take
to evaluate the robustness of a neural network: attempt to prove
a lower bound, or construct attacks that demonstrate an upper
bound. The former approach, while sound, is substantially
more difÔ¨Åcult to implement in practice, and all attempts have
required approximations [2], [21]. On the other hand, if thearXiv:1608.04644v2 [cs.CR] 22 Mar 2017attacks used in the the latter approach are not sufÔ¨Åciently
strong and fail often, the upper bound may not be useful.
In this paper we create a set of attacks that can be used
to construct an upper bound on the robustness of neural
networks. As a case study, we use these attacks to demon-
strate that defensive distillation does not actually eliminate
adversarial examples. We construct three new attacks (under
three previously used distance metrics: L0,L2, andL1) that
succeed in Ô¨Ånding adversarial examples for 100% of images
on defensively distilled networks. While defensive distillation
stops previously published attacks, it cannot resist the more
powerful attack techniques we introduce in this paper.
This case study illustrates the general need for better
techniques to evaluate the robustness of neural networks:
while distillation was shown to be secure against the current
state-of-the-art attacks, it fails against our stronger attacks.
Furthermore, when comparing our attacks against the current
state-of-the-art on standard unsecured models, our methods
generate adversarial examples with less total distortion in
every case. We suggest that our attacks are a better baseline
for evaluating candidate defenses: before placing any faith in a
new possible defense, we suggest that designers at least check
whether it can resist our attacks.
We additionally propose using high-conÔ¨Ådence adversarial
examples to evaluate the robustness of defenses. Transfer-
ability [46], [11] is the well-known property that adversarial
examples on one model are often also adversarial on another
model. We demonstrate that adversarial examples from our
attacks are transferable from the unsecured model to the
defensively distilled (secured) model. In general, we argue
that any defense must demonstrate it is able to break the
transferability property.
We evaluate our attacks on three standard datasets: MNIST
[28], a digit-recognition task (0-9); CIFAR-10 [24], a small-
image recognition task, also with 10 classes; and ImageNet
[9], a large-image recognition task with 1000 classes.
Figure 1 shows examples of adversarial examples our tech-
niques generate on defensively distilled networks trained on
the MNIST and CIFAR datasets.
In one extreme example for the ImageNet classiÔ¨Åcation task,
we can cause the Inception v3 [45] network to incorrectly
classify images by changing only the lowest order bit of each
pixel. Such changes are impossible to detect visually.
To enable others to more easily use our work to evaluate
the robustness of other defenses, all of our adversarial example
generation algorithms (along with code to train the models we
use, to reproduce the results we present) are available online
at http://nicholas.carlini.com/code/nn robust attacks.
This paper makes the following contributions:
We introduce three new attacks for the L0,L2, andL1
distance metrics. Our attacks are signiÔ¨Åcantly more effec-
tive than previous approaches. Our L0attack is the Ô¨Årst
published attack that can cause targeted misclassiÔ¨Åcation
on the ImageNet dataset.
We apply these attacks to defensive distillation and dis-
cover that distillation provides little security beneÔ¨Åt overun-distilled networks.
We propose using high-conÔ¨Ådence adversarial examples
in a simple transferability test to evaluate defenses, and
show this test breaks defensive distillation.
We systematically evaluate the choice of the objective
function for Ô¨Ånding adversarial examples, and show that
the choice can dramatically impact the efÔ¨Åcacy of an
attack.
II. B ACKGROUND
A. Threat Model
Machine learning is being used in an increasing array of
settings to make potentially security critical decisions: self-
driving cars [3], [4], drones [10], robots [33], [22], anomaly
detection [6], malware classiÔ¨Åcation [8], [40], [48], speech
recognition and recognition of voice commands [17], [13],
NLP [1], and many more. Consequently, understanding the
security properties of deep learning has become a crucial
question in this area. The extent to which we can construct
adversarial examples inÔ¨Çuences the settings in which we may
want to (or not want to) use neural networks.
In the speech recognition domain, recent work has shown
[5] it is possible to generate audio that sounds like speech to
machine learning algorithms but not to humans. This can be
used to control user‚Äôs devices without their knowledge. For
example, by playing a video with a hidden voice command,
it may be possible to cause a smart phone to visit a malicious
webpage to cause a drive-by download. This work focused
on conventional techniques (Gaussian Mixture Models and
Hidden Markov Models), but as speech recognition is increas-
ingly using neural networks, the study of adversarial examples
becomes relevant in this domain.1
In the space of malware classiÔ¨Åcation, the existence of
adversarial examples not only limits their potential application
settings, but entirely defeats its purpose: an adversary who is
able to make only slight modiÔ¨Åcations to a malware Ô¨Åle that
cause it to remain malware, but become classiÔ¨Åed as benign,
has entirely defeated the malware classiÔ¨Åer [8], [14].
Turning back to the threat to self-driving cars introduced
earlier, this is not an unrealistic attack: it has been shown that
adversarial examples are possible in the physical world [26]
after taking pictures of them.
The key question then becomes exactly how much distortion
we must add to cause the classiÔ¨Åcation to change. In each
domain, the distance metric that we must use is different. In
the space of images, which we focus on in this paper, we
rely on previous work that suggests that various Lpnorms are
reasonable approximations of human perceptual distance (see
Section II-D for more information).
We assume in this paper that the adversary has complete
access to a neural network, including the architecture and all
paramaters, and can use this in a white-box manner. This is a
conservative and realistic assumption: prior work has shown it
1Strictly speaking, hidden voice commands are not adversarial examples
because they are not similar to the original input [5].
2is possible to train a substitute model given black-box access
to a target model, and by attacking the substitute model, we
can then transfer these attacks to the target model. [37]
Given these threats, there have been various attempts [15],
[2], [20], [42], [39] at constructing defenses that increase the
robustness of a neural network, deÔ¨Åned as a measure of how
easy it is to Ô¨Ånd adversarial examples that are close to their
original input.
In this paper we study one of these, distillation as a defense
[39], that hopes to secure an arbitrary neural network. This
type of defensive distillation was shown to make generating
adversarial examples nearly impossible for existing attack
techniques [39]. We Ô¨Ånd that although the current state-of-the-
art fails to Ô¨Ånd adversarial examples for defensively distilled
networks, the stronger attacks we develop in this paper are
able to construct adversarial examples.
B. Neural Networks and Notation
A neural network is a function F(x) =ythat accepts an
inputx2Rnand produces an output y2Rm. The model F
also implicitly depends on some model parameters ; in our
work the model is Ô¨Åxed, so for convenience we don‚Äôt show
the dependence on .
In this paper we focus on neural networks used as an m-
class classiÔ¨Åer. The output of the network is computed using
the softmax function, which ensures that the output vector y
satisÔ¨Åes 0yi1andy1++ym= 1. The output vector y
is thus treated as a probability distribution, i.e., yiis treated as
the probability that input xhas classi. The classiÔ¨Åer assigns
the labelC(x) = arg max iF(x)ito the input x. LetC(x)
be the correct label of x. The inputs to the softmax function
are called logits .
We use the notation from Papernot et al. [39]: deÔ¨Åne F
to be the full neural network including the softmax function,
Z(x) =zto be the output of all layers except the softmax (so
zare the logits), and
F(x) =softmax (Z(x)) =y:
A neural network typically2consists of layers
F=softmaxFnFn 1F1
where
Fi(x) =(ix) +^i
for some non-linear activation function , some matrix iof
model weights, and some vector ^iof model biases. Together
and^make up the model parameters. Common choices of 
are tanh [31], sigmoid, ReLU [29], or ELU [7]. In this paper
we focus primarily on networks that use a ReLU activation
function, as it currently is the most widely used activation
function [45], [44], [31], [39].
We use image classiÔ¨Åcation as our primary evaluation
domain. An hw-pixel grey-scale image is a two-dimensional
2Most simple networks have this simple linear structure, however other
more sophisticated networks have more complicated structures (e.g., ResNet
[16] and Inception [45]). The network architecture does not impact our attacks.vectorx2Rhw, wherexidenotes the intensity of pixel i
and is scaled to be in the range [0;1]. A color RGB image
is a three-dimensional vector x2R3hw. We do not convert
RGB images to HSV , HSL, or other cylindrical coordinate
representations of color images: the neural networks act on
raw pixel values.
C. Adversarial Examples
Szegedy et al. [46] Ô¨Årst pointed out the existence of
adversarial examples : given a valid input xand a target
t6=C(x), it is often possible to Ô¨Ånd a similar input x0
such thatC(x0) =tyetx;x0are close according to some
distance metric. An example x0with this property is known
as a targeted adversarial example.
A less powerful attack also discussed in the literature
instead asks for untargeted adversarial examples: instead of
classifyingxas a given target class, we only search for an
inputx0so thatC(x0)6=C(x)andx;x0are close. Untargeted
attacks are strictly less powerful than targeted attacks and we
do not consider them in this paper.3
Instead, we consider three different approaches for how to
choose the target class, in a targeted attack:
Average Case: select the target class uniformly at random
among the labels that are not the correct label.
Best Case: perform the attack against all incorrect classes,
and report the target class that was least difÔ¨Åcult to attack.
Worst Case: perform the attack against all incorrect
classes, and report the target class that was most difÔ¨Åcult
to attack.
In all of our evaluations we perform all three types of
attacks: best-case, average-case, and worst-case. Notice that
if a classiÔ¨Åer is only accurate 80% of the time, then the best
case attack will require a change of 0in20% of cases.
On ImageNet, we approximate the best-case and worst-case
attack by sampling 100 random target classes out of the 1,000
possible for efÔ¨Åciency reasons.
D. Distance Metrics
In our deÔ¨Ånition of adversarial examples, we require use
of a distance metric to quantify similarity. There are three
widely-used distance metrics in the literature for generating
adversarial examples, all of which are Lpnorms.
TheLpdistance is written kx x0kp, where the p-norm
kkpis deÔ¨Åned as
kvkp= nX
i=1jvijp!1
p
:
In more detail:
3An untargeted attack is simply a more efÔ¨Åcient (and often less accurate)
method of running a targeted attack for each target and taking the closest.
In this paper we focus on identifying the most accurate attacks, and do not
consider untargeted attacks.
31)L0distance measures the number of coordinates isuch
thatxi6=x0
i. Thus, theL0distance corresponds to the
number of pixels that have been altered in an image.4
Papernot et al. argue for the use of the L0distance
metric, and it is the primary distance metric under which
defensive distillation‚Äôs security is argued [39].
2)L2distance measures the standard Euclidean (root-
mean-square) distance between xandx0. TheL2dis-
tance can remain small when there are many small
changes to many pixels.
This distance metric was used in the initial adversarial
example work [46].
3)L1distance measures the maximum change to any of
the coordinates:
kx x0k1= max(jx1 x0
1j;:::;jxn x0
nj):
For images, we can imagine there is a maximum budget,
and each pixel is allowed to be changed by up to this
limit, with no limit on the number of pixels that are
modiÔ¨Åed.
Goodfellow et al. argue thatL1is the optimal distance
metric to use [47] and in a follow-up paper Papernot et
al.argue distillation is secure under this distance metric
[36].
No distance metric is a perfect measure of human perceptual
similarity, and we pass no judgement on exactly which dis-
tance metric is optimal. We believe constructing and evaluating
a good distance metric is an important research question we
leave to future work.
However, since most existing work has picked one of these
three distance metrics, and since defensive distillation argued
security against two of these, we too use these distance metrics
and construct attacks that perform superior to the state-of-the-
art for each of these distance metrics.
When reporting all numbers in this paper, we report using
the distance metric as deÔ¨Åned above, on the range [0;1]. (That
is, changing a pixel in a greyscale image from full-on to full-
off will result in L2change of 1:0and aL1change of 1:0,
not255.)
E. Defensive Distillation
We brieÔ¨Çy provide a high-level overview of defensive distil-
lation. We provide a complete description later in Section VIII.
To defensively distill a neural network, begin by Ô¨Årst
training a network with identical architecture on the training
data in a standard manner. When we compute the softmax
while training this network, replace it with a more-smooth
version of the softmax (by dividing the logits by some constant
T). At the end of training, generate the soft training labels by
evaluating this network on each of the training instances and
taking the output labels of the network.
4In RGB images, there are three channels that each can change. We count
the number of pixels that are different, where two pixels are considered
different if any of the three colors are different. We do not consider a
distance metric where an attacker can change one color plane but not another
meaningful. We relax this requirement when comparing to other L0attacks
that do not make this assumption to provide for a fair comparison.Then, throw out the Ô¨Årst network and use only the soft
training labels. With those, train a second network where
instead of training it on the original training labels, use the
soft labels. This trains the second model to behave like the Ô¨Årst
model, and the soft labels convey additional hidden knowledge
learned by the Ô¨Årst model.
The key insight here is that by training to match the Ô¨Årst
network, we will hopefully avoid over-Ô¨Åtting against any of the
training data. If the reason that neural networks exist is because
neural networks are highly non-linear and have ‚Äúblind spots‚Äù
[46] where adversarial examples lie, then preventing this type
of over-Ô¨Åtting might remove those blind spots.
In fact, as we will see later, defensive distillation does not
remove adversarial examples. One potential reason this may
occur is that others [11] have argued the reason adversarial
examples exist is not due to blind spots in a highly non-linear
neural network, but due only to the locally-linear nature of
neural networks. This so-called linearity hypothesis appears
to be true [47], and under this explanation it is perhaps less
surprising that distillation does not increase the robustness of
neural networks.
F . Organization
The remainder of this paper is structured as follows. In
the next section, we survey existing attacks that have been
proposed in the literature for generating adversarial examples,
for theL2,L1, andL0distance metrics. We then describe
our attack algorithms that target the same three distance
metrics and provide superior results to the prior work. Having
developed these attacks, we review defensive distillation in
more detail and discuss why the existing attacks fail to Ô¨Ånd ad-
versarial examples on defensively distilled networks. Finally,
we attack defensive distillation with our new algorithms and
show that it provides only limited value.
III. A TTACK ALGORITHMS
A. L-BFGS
Szegedy et al. [46] generated adversarial examples using
box-constrained L-BFGS. Given an image x, their method
Ô¨Ånds a different image x0that is similar to xunderL2distance,
yet is labeled differently by the classiÔ¨Åer. They model the
problem as a constrained minimization problem:
minimizekx x0k2
2
such thatC(x0) =l
x02[0;1]n
This problem can be very difÔ¨Åcult to solve, however, so
Szegedy et al. instead solve the following problem:
minimizeckx x0k2
2+lossF;l(x0)
such thatx02[0;1]n
where loss F;lis a function mapping an image to a positive real
number. One common loss function to use is cross-entropy.
Line search is performed to Ô¨Ånd the constant c>0that yields
an adversarial example of minimum distance: in other words,
4we repeatedly solve this optimization problem for multiple
values ofc, adaptively updating cusing bisection search or
any other method for one-dimensional optimization.
B. Fast Gradient Sign
The fast gradient sign [11] method has two key differences
from the L-BFGS method: Ô¨Årst, it is optimized for the L1
distance metric, and second, it is designed primarily to be fast
instead of producing very close adversarial examples. Given
an imagexthe fast gradient sign method sets
x0=x sign(rlossF;t(x));
whereis chosen to be sufÔ¨Åciently small so as to be
undetectable, and tis the target label. Intuitively, for each
pixel, the fast gradient sign method uses the gradient of
the loss function to determine in which direction the pixel‚Äôs
intensity should be changed (whether it should be increased
or decreased) to minimize the loss function; then, it shifts all
pixels simultaneously.
It is important to note that the fast gradient sign attack was
designed to be fast, rather than optimal. It is not meant to
produce the minimal adversarial perturbations.
Iterative Gradient Sign: Kurakin et al. introduce a simple
reÔ¨Ånement of the fast gradient sign method [26] where instead
of taking a single step of size in the direction of the gradient-
sign, multiple smaller steps are taken, and the result is
clipped by the same . SpeciÔ¨Åcally, begin by setting
x0
0= 0
and then on each iteration
x0
i=x0
i 1 clip(sign(rlossF;t(x0
i 1)))
Iterative gradient sign was found to produce superior results
to fast gradient sign [26].
C. JSMA
Papernot et al. introduced an attack optimized under L0
distance [38] known as the Jacobian-based Saliency Map
Attack (JSMA). We give a brief summary of their attack
algorithm; for a complete description and motivation, we
encourage the reader to read their original paper [38].
At a high level, the attack is a greedy algorithm that
picks pixels to modify one at a time, increasing the target
classiÔ¨Åcation on each iteration. They use the gradient rZ(x)l
to compute a saliency map , which models the impact each
pixel has on the resulting classiÔ¨Åcation. A large value indicates
that changing it will signiÔ¨Åcantly increase the likelihood of
the model labeling the image as the target class l. Given the
saliency map, it picks the most important pixel and modify
it to increase the likelihood of class l. This is repeated until
either more than a set threshold of pixels are modiÔ¨Åed which
makes the attack detectable, or it succeeds in changing the
classiÔ¨Åcation.In more detail, we begin by deÔ¨Åning the saliency map in
terms of a pair of pixels p;q. DeÔ¨Åne
pq=X
i2fp;qg@Z(x)t
@xi
pq=0
@X
i2fp;qgX
j@Z(x)j
@xi1
A pq
so thatpqrepresents how much changing both pixels pand
qwill change the target classiÔ¨Åcation, and pqrepresents how
much changing pandqwill change all other outputs. Then
the algorithm picks
(p;q) = arg max
(p;q)( pqpq)(pq>0)(pq<0)
so thatpq>0(the target class is more likely), pq<0(the
other classes become less likely), and  pqpqis largest.
Notice that JSMA uses the output of the second-to-last layer
Z, the logits, in the calculation of the gradient: the output of
the softmax Fisnotused. We refer to this as the JSMA-Z
attack.
However, when the authors apply this attack to their defen-
sively distilled networks, they modify the attack so it uses F
instead ofZ. In other words, their computation uses the output
of the softmax ( F) instead of the logits ( Z). We refer to this
modiÔ¨Åcation as the JSMA-F attack.5
When an image has multiple color channels (e.g., RGB),
this attack considers the L0difference to be 1for each color
channel changed independently (so that if all three color
channels of one pixel change change, the L0norm would be
3). While we do not believe this is a meaningful threat model,
when comparing to this attack, we evaluate under both models.
D. Deepfool
Deepfool [34] is an untargeted attack technique optimized
for theL2distance metric. It is efÔ¨Åcient and produces closer
adversarial examples than the L-BFGS approach discussed
earlier.
The authors construct Deepfool by imagining that the neural
networks are totally linear, with a hyperplane separating each
class from another. From this, they analytically derive the
optimal solution to this simpliÔ¨Åed problem, and construct the
adversarial example.
Then, since neural networks are not actually linear, they take
a step towards that solution, and repeat the process a second
time. The search terminates when a true adversarial example
is found.
The exact formulation used is rather sophisticated; inter-
ested readers should refer to the original work [34].
IV. E XPERIMENTAL SETUP
Before we develop our attack algorithms to break distilla-
tion, we describe how we train the models on which we will
evaluate our attacks.
5We veriÔ¨Åed this via personal communication with the authors.
5Layer Type MNIST Model CIFAR Model
Convolution + ReLU 3 332 3 364
Convolution + ReLU 3 332 3 364
Max Pooling 2 2 2 2
Convolution + ReLU 3 364 3 3128
Convolution + ReLU 3 364 3 3128
Max Pooling 2 2 2 2
Fully Connected + ReLU 200 256
Fully Connected + ReLU 200 256
Softmax 10 10
TABLE I
MODEL ARCHITECTURES FOR THE MNIST AND CIFAR MODELS . THIS
ARCHITECTURE IS IDENTICAL TO THAT OF THE ORIGINAL DEFENSIVE
DISTILLATION WORK . [39]
Parameter MNIST Model CIFAR Model
Learning Rate 0.1 0.01 (decay 0.5)
Momentum 0.9 0.9 (decay 0.5)
Delay Rate - 10 epochs
Dropout 0.5 0.5
Batch Size 128 128
Epochs 50 50
TABLE II
MODEL PARAMETERS FOR THE MNIST AND CIFAR MODELS . THESE
PARAMETERS ARE IDENTICAL TO THAT OF THE ORIGINAL DEFENSIVE
DISTILLATION WORK . [39]
We train two networks for the MNIST [28] and CIFAR-10
[24] classiÔ¨Åcation tasks, and use one pre-trained network for
the ImageNet classiÔ¨Åcation task [41]. Our models and training
approaches are identical to those presented in [39]. We achieve
99:5%accuracy on MNIST, comparable to the state of the
art. On CIFAR-10, we achieve 80% accuracy, identical to the
accuracy given in the distillation work.6
MNIST and CIFAR-10. The model architecture is given in
Table I and the hyperparameters selected in Table II. We use
a momentum-based SGD optimizer during training.
The CIFAR-10 model signiÔ¨Åcantly overÔ¨Åts the training data
even with dropout: we obtain a Ô¨Ånal training cross-entropy
loss of 0:05with accuracy 98%, compared to a validation
loss of 1:2with validation accuracy 80%. We do not alter
the network by performing image augmentation or adding
additional dropout as that was not done in [39].
ImageNet. Along with considering MNIST and CIFAR,
which are both relatively small datasets, we also consider
the ImageNet dataset. Instead of training our own ImageNet
model, we use the pre-trained Inception v3 network [45],
which achieves 96% top-5 accuracy (that is, the probability
that the correct class is one of the Ô¨Åve most likely as reported
by the network is 96%). Inception takes images as 2992993
dimensional vectors.
6This is compared to the state-of-the-art result of 95% [12], [44], [31].
However, in order to provide the most accurate comparison to the original
work, we feel it is important to reproduce their model architectures.V. O URAPPROACH
We now turn to our approach for constructing adversarial
examples. To begin, we rely on the initial formulation of
adversarial examples [46] and formally deÔ¨Åne the problem of
Ô¨Ånding an adversarial instance for an image xas follows:
minimizeD(x;x+)
such thatC(x+) =t
x+2[0;1]n
wherexis Ô¨Åxed, and the goal is to Ô¨Ånd that minimizes
D(x;x+). That is, we want to Ô¨Ånd some small change that
we can make to an image xthat will change its classiÔ¨Åcation,
but so that the result is still a valid image. Here Dis some
distance metric; for us, it will be either L0,L2, orL1as
discussed earlier.
We solve this problem by formulating it as an appropriate
optimization instance that can be solved by existing optimiza-
tion algorithms. There are many possible ways to do this;
we explore the space of formulations and empirically identify
which ones lead to the most effective attacks.
A. Objective Function
The above formulation is difÔ¨Åcult for existing algorithms
to solve directly, as the constraint C(x+) =tis highly
non-linear. Therefore, we express it in a different form that is
better suited for optimization. We deÔ¨Åne an objective function
fsuch thatC(x+) =tif and only if f(x+)0. There
are many possible choices for f:
f1(x0) = lossF;t(x0) + 1
f2(x0) = (max
i6=t(F(x0)i) F(x0)t)+
f3(x0) =softplus (max
i6=t(F(x0)i) F(x0)t) log(2)
f4(x0) = (0:5 F(x0)t)+
f5(x0) = log(2F(x0)t 2)
f6(x0) = (max
i6=t(Z(x0)i) Z(x0)t)+
f7(x0) =softplus (max
i6=t(Z(x0)i) Z(x0)t) log(2)
wheresis the correct classiÔ¨Åcation, (e)+is short-hand for
max(e;0), softplus (x) = log(1 + exp( x)), and loss F;s(x)is
the cross entropy loss for x.
Notice that we have adjusted some of the above formula by
adding a constant; we have done this only so that the function
respects our deÔ¨Ånition. This does not impact the Ô¨Ånal result,
as it just scales the minimization function.
Now, instead of formulating the problem as
minimizeD(x;x+)
such thatf(x+)0
x+2[0;1]n
we use the alternative formulation:
minimizeD(x;x+) +cf(x+)
such thatx+2[0;1]n
60.0 0.2 0.4 0.6 0.8 1.0Success Probability
0 2 4 6 8 10
Mean Adversarial Example Distance
1e‚àí02 1e‚àí01 1e+00 1e+01 1e+02
Constant c usedFig. 2. Sensitivity on the constant c. We plot the L2distance of the adversarial
example computed by gradient descent as a function of c, for objective
functionf6. Whenc < : 1, the attack rarely succeeds. After c > 1, the
attack becomes less effective, but always succeeds.
wherec > 0is a suitably chosen constant. These two are
equivalent, in the sense that there exists c >0such that the
optimal solution to the latter matches the optimal solution to
the former. After instantiating the distance metric Dwith an
lpnorm, the problem becomes: given x, Ô¨Åndthat solves
minimizekkp+cf(x+)
such thatx+2[0;1]n
Choosing the constant c.
Empirically, we have found that often the best way to choose
cis to use the smallest value of cfor which the resulting
solutionxhasf(x)0. This causes gradient descent to
minimize both of the terms simultaneously instead of picking
only one to optimize over Ô¨Årst.
We verify this by running our f6formulation (which we
found most effective) for values of cspaced uniformly (on a
log scale) from c= 0:01toc= 100 on the MNIST dataset.
We plot this line in Figure 2.7
Further, we have found that if choose the smallest csuch
thatf(x)0, the solution is within 5%of optimal 70% of
the time, and within 30% of optimal 98% of the time, where
‚Äúoptimal‚Äù refers to the solution found using the best value of
c. Therefore, in our implementations we use modiÔ¨Åed binary
search to choose c.
7The corresponding Ô¨Ågures for other objective functions are similar; we
omit them for brevity.B. Box constraints
To ensure the modiÔ¨Åcation yields a valid image, we have a
constraint on : we must have 0xi+i1for alli. In the
optimization literature, this is known as a ‚Äúbox constraint.‚Äù
Previous work uses a particular optimization algorithm, L-
BFGS-B, which supports box constraints natively.
We investigate three different methods of approaching this
problem.
1)Projected gradient descent performs one step of standard
gradient descent, and then clips all the coordinates to be
within the box.
This approach can work poorly for gradient descent
approaches that have a complicated update step (for
example, those with momentum): when we clip the
actualxi, we unexpectedly change the input to the next
iteration of the algorithm.
2)Clipped gradient descent does not clip xion each
iteration; rather, it incorporates the clipping into the
objective function to be minimized. In other words, we
replacef(x+)withf(min(max(x+;0);1)), with
the min and max taken component-wise.
While solving the main issue with projected gradient de-
scent, clipping introduces a new problem: the algorithm
can get stuck in a Ô¨Çat spot where it has increased some
componentxito be substantially larger than the maxi-
mum allowed. When this happens, the partial derivative
becomes zero, so even if some improvement is possible
by later reducing xi, gradient descent has no way to
detect this.
3)Change of variables introduces a new variable wand
instead of optimizing over the variable deÔ¨Åned above,
we apply a change-of-variables and optimize over w,
setting
i=1
2(tanh(wi) + 1) xi:
Since 1tanh(wi)1, it follows that 0xi+i
1, so the solution will automatically be valid.8
We can think of this approach as a smoothing of clipped
gradient descent that eliminates the problem of getting
stuck in extreme regions.
These methods allow us to use other optimization algo-
rithms that don‚Äôt natively support box constraints. We use the
Adam [23] optimizer almost exclusively, as we have found it to
be the most effective at quickly Ô¨Ånding adversarial examples.
We tried three solvers ‚Äî standard gradient descent, gradient
descent with momentum, and Adam ‚Äî and all three produced
identical-quality solutions. However, Adam converges substan-
tially more quickly than the others.
C. Evaluation of approaches
For each possible objective function f()and method to
enforce the box constraint, we evaluate the quality of the
adversarial examples found.
8Instead of scaling by1
2we scale by1
2+to avoid dividing by zero.
7Best Case Average Case Worst Case
Change of Clipped Projected Change of Clipped Projected Change of Clipped Projected
Variable Descent Descent Variable Descent Descent Variable Descent Descent
mean prob mean prob mean prob mean prob mean prob mean prob mean prob mean prob mean prob
f1 2.46 100 % 2.93 100 % 2.31 100 % 4.35 100 % 5.21 100 % 4.11 100 % 7.76 100 % 9.48 100 % 7.37 100 %
f2 4.55 80 % 3.97 83 % 3.49 83 % 3.22 44 % 8.99 63 % 15.06 74 % 2.93 18 % 10.22 40 % 18.90 53 %
f3 4.54 77 % 4.07 81 % 3.76 82 % 3.47 44 % 9.55 63 % 15.84 74 % 3.09 17 % 11.91 41 % 24.01 59 %
f4 5.01 86 % 6.52 100 % 7.53 100 % 4.03 55 % 7.49 71 % 7.60 71 % 3.55 24 % 4.25 35 % 4.10 35 %
f5 1.97 100 % 2.20 100 % 1.94 100 % 3.58 100 % 4.20 100 % 3.47 100 % 6.42 100 % 7.86 100 % 6.12 100 %
f6 1.94 100 % 2.18 100 % 1.95 100 % 3.47 100 % 4.11 100 % 3.41 100 % 6.03 100 % 7.50 100 % 5.89 100 %
f7 1.96 100 % 2.21 100 % 1.94 100 % 3.53 100 % 4.14 100 % 3.43 100 % 6.20 100 % 7.57 100 % 5.94 100 %
TABLE III
EVALUATION OF ALL COMBINATIONS OF ONE OF THE SEVEN POSSIBLE OBJECTIVE FUNCTIONS WITH ONE OF THE THREE BOX CONSTRAINT ENCODINGS .
WE SHOW THE AVERAGE L2DISTORTION ,THE STANDARD DEVIATION ,AND THE SUCCESS PROBABILITY (FRACTION OF INSTANCES FOR WHICH AN
ADVERSARIAL EXAMPLE CAN BE FOUND ). E VALUATED ON 1000 RANDOM INSTANCES . W HEN THE SUCCESS IS NOT 100% ,MEAN IS FOR SUCCESSFUL
ATTACKS ONLY .
To choose the optimal c, we perform 20iterations of binary
search over c. For each selected value of c, we run 10;000
iterations of gradient descent with the Adam optimizer.9
The results of this analysis are in Table III. We evaluate
the quality of the adversarial examples found on the MNIST
and CIFAR datasets. The relative ordering of each objective
function is identical between the two datasets, so for brevity
we report only results for MNIST.
There is a factor of three difference in quality between the
best objective function and the worst. The choice of method
for handling box constraints does not impact the quality of
results as signiÔ¨Åcantly for the best minimization functions.
In fact, the worst performing objective function, cross
entropy loss, is the approach that was most suggested in the
literature previously [46], [42].
Why are some loss functions better than others? Whenc=
0, gradient descent will not make any move away from the
initial image. However, a large coften causes the initial steps
of gradient descent to perform in an overly-greedy manner,
only traveling in the direction which can most easily reduce
fand ignoring theDloss ‚Äî thus causing gradient descent to
Ô¨Ånd sub-optimal solutions.
This means that for loss function f1andf4, there is no
good constant cthat is useful throughout the duration of
the gradient descent search. Since the constant cweights the
relative importance of the distance term and the loss term, in
order for a Ô¨Åxed constant cto be useful, the relative value of
these two terms should remain approximately equal. This is
not the case for these two loss functions.
To explain why this is the case, we will have to take a side
discussion to analyze how adversarial examples exist. Consider
a valid input xand an adversarial example x0on a network.
What does it look like as we linearly interpolate from xto
x0? That is, let y=x+(1 )x0for2[0;1]. It turns out the
value ofZ()tis mostly linear from the input to the adversarial
example, and therefore the F()tis a logistic. We verify this
fact empirically by constructing adversarial examples on the
9Adam converges to 95% of optimum within 1;000 iterations 92% of the
time. For completeness we run it for 10;000 iterations at each step.Ô¨Årst1;000test images on both the MNIST and CIFAR dataset
with our approach, and Ô¨Ånd the Pearson correlation coefÔ¨Åcient
r>: 9.
Given this, consider loss function f4(the argument for f1is
similar). In order for the gradient descent attack to make any
change initially, the constant cwill have to be large enough
that
<c (f1(x+) f1(x))
or, as!0,
1=c<jrf1(x)j
implying that cmust be larger than the inverse of the gradient
to make progress, but the gradient of f1is identical to F()t
so will be tiny around the initial image, meaning cwill have
to be extremely large.
However, as soon as we leave the immediate vicinity of
the initial image, the gradient of rf1(x+)increases at an
exponential rate, making the large constant ccause gradient
descent to perform in an overly greedy manner.
We verify all of this theory empirically. When we run our
attack trying constants chosen from 10 10to1010the average
constant for loss function f4was106.
The average gradient of the loss function f1around the valid
image is 2 20but2 1at the closest adversarial example. This
meanscis a million times larger than it has to be, causing
the loss function f4andf1to perform worse than any of the
others.
D. Discretization
We model pixel intensities as a (continuous) real number in
the range [0;1]. However, in a valid image, each pixel intensity
must be a (discrete) integer in the range f0;1;:::; 255g. This
additional requirement is not captured in our formulation.
In practice, we ignore the integrality constraints, solve the
continuous optimization problem, and then round to the nearest
integer: the intensity of the ith pixel becomesb255(xi+i)e.
This rounding will slightly degrade the quality of the
adversarial example. If we need to restore the attack quality,
we perform greedy search on the lattice deÔ¨Åned by the discrete
8Target ClassiÔ¨Åcation ( L2)
0 1 2 3 4 5 6 7 8 9Source ClassiÔ¨Åcation
9 8 7 6 5 4 3 2 1 0
Fig. 3. OurL2adversary applied to the MNIST dataset performing a targeted
attack for every source/target pair. Each digit is the Ô¨Årst image in the dataset
with that label.
solutions by changing one pixel value at a time. This greedy
search never failed for any of our attacks.
Prior work has largely ignored the integrality constraints.10
For instance, when using the fast gradient sign attack with =
0:1(i.e., changing pixel values by 10%), discretization rarely
affects the success rate of the attack. In contrast, in our work,
we are able to Ô¨Ånd attacks that make much smaller changes
to the images, so discretization effects cannot be ignored. We
take care to always generate valid images; when reporting the
success rate of our attacks, they always are for attacks that
include the discretization post-processing.
VI. O URTHREE ATTACKS
A. OurL2Attack
Putting these ideas together, we obtain a method for Ô¨Ånding
adversarial examples that will have low distortion in the L2
metric. Given x, we choose a target class t(such that we have
t6=C(x)) and then search for wthat solves
minimizek1
2(tanh(w) + 1) xk2
2+cf(1
2(tanh(w) + 1)
withfdeÔ¨Åned as
f(x0) = max(maxfZ(x0)i:i6=tg Z(x0)t; ):
Thisfis based on the best objective function found earlier,
modiÔ¨Åed slightly so that we can control the conÔ¨Ådence with
which the misclassiÔ¨Åcation occurs by adjusting . The param-
eterencourages the solver to Ô¨Ånd an adversarial instance
x0that will be classiÔ¨Åed as class twith high conÔ¨Ådence. We
set= 0 for our attacks but we note here that a side beneÔ¨Åt
10One exception: The JSMA attack [38] handles this by only setting the
output value to either 0 or 255.Target ClassiÔ¨Åcation ( L0)
0 1 2 3 4 5 6 7 8 9Source ClassiÔ¨Åcation
9 8 7 6 5 4 3 2 1 0
Fig. 4. OurL0adversary applied to the MNIST dataset performing a targeted
attack for every source/target pair. Each digit is the Ô¨Årst image in the dataset
with that label.
of this formulation is it allows one to control for the desired
conÔ¨Ådence. This is discussed further in Section VIII-D.
Figure 3 shows this attack applied to our MNIST model
for each source digit and target digit. Almost all attacks are
visually indistinguishable from the original digit.
A comparable Ô¨Ågure (Figure 12) for CIFAR is in the ap-
pendix. No attack is visually distinguishable from the baseline
image.
Multiple starting-point gradient descent. The main problem
with gradient descent is that its greedy search is not guaranteed
to Ô¨Ånd the optimal solution and can become stuck in a local
minimum. To remedy this, we pick multiple random starting
points close to the original image and run gradient descent
from each of those points for a Ô¨Åxed number of iterations.
We randomly sample points uniformly from the ball of radius
r, whereris the closest adversarial example found so far.
Starting from multiple starting points reduces the likelihood
that gradient descent gets stuck in a bad local minimum.
B. OurL0Attack
TheL0distance metric is non-differentiable and therefore
is ill-suited for standard gradient descent. Instead, we use an
iterative algorithm that, in each iteration, identiÔ¨Åes some pixels
that don‚Äôt have much effect on the classiÔ¨Åer output and then
Ô¨Åxes those pixels, so their value will never be changed. The
set of Ô¨Åxed pixels grows in each iteration until we have, by
process of elimination, identiÔ¨Åed a minimal (but possibly not
minimum) subset of pixels that can be modiÔ¨Åed to generate an
adversarial example. In each iteration, we use our L2attack
to identify which pixels are unimportant.
In more detail, on each iteration, we call the L2adversary,
restricted to only modify the pixels in the allowed set. Let
9be the solution returned from the L2adversary on input
imagex, so thatx+is an adversarial example. We compute
g=rf(x+)(the gradient of the objective function,
evaluated at the adversarial instance). We then select the pixel
i= arg min igiiand Ô¨Åxi, i.e., remove ifrom the allowed
set.11The intuition is that giitells us how much reduction to
f()we obtain from the ith pixel of the image, when moving
fromxtox+:gitells us how much reduction in fwe
obtain, per unit change to the ith pixel, and we multiply this
by how much the ith pixel has changed. This process repeats
until theL2adversary fails to Ô¨Ånd an adversarial example.
There is one Ô¨Ånal detail required to achieve strong results:
choosing a constant cto use for the L2adversary. To do this,
we initially set cto a very low value (e.g., 10 4). We then
run ourL2adversary at this c-value. If it fails, we double c
and try again, until it is successful. We abort the search if c
exceeds a Ô¨Åxed threshold (e.g., 1010).
JSMA grows a set ‚Äî initially empty ‚Äî of pixels that are
allowed to be changed and sets the pixels to maximize the total
loss. In contrast, our attack shrinks the set of pixels ‚Äî initially
containing every pixel ‚Äî that are allowed to be changed.
Our algorithm is signiÔ¨Åcantly more effective than JSMA
(see Section VII for an evaluation). It is also efÔ¨Åcient: we
introduce optimizations that make it about as fast as our L2
attack with a single starting point on MNIST and CIFAR; it is
substantially slower on ImageNet. Instead of starting gradient
descent in each iteration from the initial image, we start the
gradient descent from the solution found on the previous
iteration (‚Äúwarm-start‚Äù). This dramatically reduces the number
of rounds of gradient descent needed during each iteration, as
the solution with kpixels held constant is often very similar
to the solution with k+ 1pixels held constant.
Figure 4 shows the L0attack applied to one digit of each
source class, targeting each target class, on the MNIST dataset.
The attacks are visually noticeable, implying the L0attack is
more difÔ¨Åcult than L2. Perhaps the worst case is that of a 7
being made to classify as a 6; interestingly, this attack for L2
is one of the only visually distinguishable attacks.
A comparable Ô¨Ågure (Figure 11) for CIFAR is in the
appendix.
C. OurL1Attack
TheL1distance metric is not fully differentiable and
standard gradient descent does not perform well for it. We
experimented with naively optimizing
minimizecf(x+) +kk1
However, we found that gradient descent produces very poor
results: thekk1term only penalizes the largest (in absolute
value) entry in and has no impact on any of the other. As
such, gradient descent very quickly becomes stuck oscillating
between two suboptimal solutions. Consider a case where i=
0:5andj= 0:5 . TheL1norm will only penalize i,
11Selecting the index ithat minimizes iis simpler, but it yields results
with1:5higherL0distortion.Target ClassiÔ¨Åcation ( L1)
0 1 2 3 4 5 6 7 8 9Source ClassiÔ¨Åcation
9 8 7 6 5 4 3 2 1 0
Fig. 5. OurL1adversary applied to the MNIST dataset performing a targeted
attack for every source/target pair. Each digit is the Ô¨Årst image in the dataset
with that label.
notj, and@
@jkk1will be zero at this point. Thus, the
gradient imposes no penalty for increasing j, even though it
is already large. On the next iteration we might move to a
position where jis slightly larger than i, sayi= 0:5 0
andj= 0:5 +00, a mirror image of where we started. In
other words, gradient descent may oscillate back and forth
across the line i=j= 0:5, making it nearly impossible to
make progress.
We resolve this issue using an iterative attack. We replace
theL2term in the objective function with a penalty for any
terms that exceed (initially 1, decreasing in each iteration).
This prevents oscillation, as this loss term penalizes all large
values simultaneously. SpeciÔ¨Åcally, in each iteration we solve
minimizecf(x+) +X
i
(i )+
After each iteration, if i<for alli, we reduce by a factor
of 0.9 and repeat; otherwise, we terminate the search.
Again we must choose a good constant cto use for the
L1adversary. We take the same approach as we do for the
L0attack: initially set cto a very low value and run the L1
adversary at this c-value. If it fails, we double cand try again,
until it is successful. We abort the search if cexceeds a Ô¨Åxed
threshold.
Using ‚Äúwarm-start‚Äù for gradient descent in each iteration,
this algorithm is about as fast as our L2algorithm (with a
single starting point).
Figure 5 shows the L1attack applied to one digit of each
source class, targeting each target class, on the MNSIT dataset.
While most differences are not visually noticeable, a few are.
Again, the worst case is that of a 7 being made to classify as
a 6.
10A comparable Ô¨Ågure (Figure 13) for CIFAR is in the ap-
pendix. No attack is visually distinguishable from the baseline
image.
VII. A TTACK EVALUATION
We compare our targeted attacks to the best results pre-
viously reported in prior publications, for each of the three
distance metrics.
We re-implement Deepfool, fast gradient sign, and iterative
gradient sign. For fast gradient sign, we search over to Ô¨Ånd
the smallest distance that generates an adversarial example;
failures is returned if no produces the target class. Our
iterative gradient sign method is similar: we search over 
(Ô¨Åxing=1
256) and return the smallest successful.
For JSMA we use the implementation in CleverHans [35]
with only slight modiÔ¨Åcation (we improve performance by
50with no impact on accuracy).
JSMA is unable to run on ImageNet due to an inherent
signiÔ¨Åcant computational cost: recall that JSMA performs
search for a pair of pixels p;qthat can be changed together
that make the target class more likely and other classes less
likely. ImageNet represents images as 2992993vectors,
so searching over all pairs of pixels would require 236work
on each step of the calculation. If we remove the search over
pairs of pixels, the success of JSMA falls off dramatically. We
therefore report it as failing always on ImageNet.
We report success if the attack produced an adversarial
example with the correct target label, no matter how much
change was required. Failure indicates the case where the
attack was entirely unable to succeed.
We evaluate on the Ô¨Årst 1;000 images in the test set on
CIFAR and MNSIT. On ImageNet, we report on 1;000images
that were initially classiÔ¨Åed correctly by Inception v312. On
ImageNet we approximate the best-case and worst-case results
by choosing 100target classes ( 10%) at random.
The results are found in Table IV for MNIST and CIFAR,
and Table V for ImageNet.13
For each distance metric, across all three datasets, our
attacks Ô¨Ånd closer adversarial examples than the previous
state-of-the-art attacks, and our attacks never fail to Ô¨Ånd an
adversarial example. Our L0andL2attacks Ô¨Ånd adversarial
examples with 2to10lower distortion than the best pre-
viously published attacks, and succeed with 100% probability.
OurL1attacks are comparable in quality to prior work, but
their success rate is higher. Our L1attacks on ImageNet are so
successful that we can change the classiÔ¨Åcation of an image
to any desired label by only Ô¨Çipping the lowest bit of each
pixel, a change that would be impossible to detect visually.
As the learning task becomes increasingly more difÔ¨Åcult, the
previous attacks produce worse results, due to the complexity
of the model. In contrast, our attacks perform even better as
the task complexity increases. We have found JSMA is unable
12Otherwise the best-case attack results would appear to succeed extremely
often artiÔ¨Åcially low due to the relatively low top-1 accuracy
13The complete code to reproduce these tables and Ô¨Ågures is available
online at http://nicholas.carlini.com/code/nn robust attacks.Target ClassiÔ¨Åcation
0 1 2 3 4 5 6 7 8 9Distance Metric
L1L2L0
Fig. 6. Targeted attacks for each of the 10 MNIST digits where the starting
image is totally black for each of the three distance metrics.
Target ClassiÔ¨Åcation
0 1 2 3 4 5 6 7 8 9Distance Metric
L1L2L0
Fig. 7. Targeted attacks for each of the 10 MNIST digits where the starting
image is totally white for each of the three distance metrics.
to Ô¨Ånd targeted L0adversarial examples on ImageNet, whereas
ours is able to with 100% success.
It is important to realize that the results between models
are not directly comparable. For example, even though a L0
adversary must change 10times as many pixels to switch an
ImageNet classiÔ¨Åcation compared to a MNIST classiÔ¨Åcation,
ImageNet has 114as many pixels and so the fraction of
pixels that must change is signiÔ¨Åcantly smaller.
Generating synthetic digits. With our targeted adversary,
we can start from any image we want and Ô¨Ånd adversarial
examples of each given target. Using this, in Figure 6 we
show the minimum perturbation to an entirely-black image
required to make it classify as each digit, for each of the
distance metrics.
This experiment was performed for the L0task previously
[38], however when mounting their attack, ‚Äúfor classes 0, 2,
3 and 5 one can clearly recognize the target digit.‚Äù With our
more powerful attacks, none of the digits are recognizable.
Figure 7 performs the same analysis starting from an all-white
image.
Notice that the all-black image requires no change to
become a digit 1because it is initially classiÔ¨Åed as a 1, and
the all-white image requires no change to become a 8because
the initial image is already an 8.
Runtime Analysis. We believe there are two reasons why one
may consider the runtime performance of adversarial example
generation algorithms important: Ô¨Årst, to understand if the
performance would be prohibitive for an adversary to actually
mount the attacks, and second, to be used as an inner loop in
11Best Case Average Case Worst Case
MNIST CIFAR MNIST CIFAR MNIST CIFAR
mean prob mean prob mean prob mean prob mean prob mean prob
OurL0 8:5 100% 5 :9 100% 16 100% 13 100% 33 100% 24 100%
JSMA-Z 20 100% 20 100% 56 100% 58 100% 180 98% 150 100%
JSMA-F 17 100% 25 100% 45 100% 110 100% 100 100% 240 100%
OurL2 1:36 100% 0 :17 100% 1:76 100% 0 :33 100% 2:60 100% 0 :51 100%
Deepfool 2:11 100% 0 :85 100%   -   -   -   -
OurL1 0:13 100% 0 :0092 100% 0:16 100% 0 :013 100% 0:23 100% 0 :019 100%
Fast Gradient Sign 0:22 100% 0 :015 99% 0:26 42% 0 :029 51%   0% 0:34 1%
Iterative Gradient Sign 0:14 100% 0 :0078 100% 0:19 100% 0 :014 100% 0:26 100% 0 :023 100%
TABLE IV
COMPARISON OF THE THREE VARIANTS OF TARGETED ATTACK TO PREVIOUS WORK FOR OUR MNIST AND CIFAR MODELS . W HEN SUCCESS RATE IS
NOT100% ,THE MEAN IS ONLY OVER SUCCESSES .
Untargeted Average Case Least Likely
mean prob mean prob mean prob
OurL0 48 100% 410 100% 5200 100%
JSMA-Z - 0% - 0% - 0%
JSMA-F - 0% - 0% - 0%
OurL2 0.32 100% 0.96 100% 2.22 100%
Deepfool 0.91 100% - - - -
OurL1 0.004 100% 0.006 100% 0.01 100%
FGS 0.004 100% 0.064 2% - 0%
IGS 0.004 100% 0.01 99% 0.03 98%
TABLE V
COMPARISON OF THE THREE VARIANTS OF TARGETED ATTACK TO
PREVIOUS WORK FOR THE INCEPTION V 3MODEL ON IMAGE NET. W HEN
SUCCESS RATE IS NOT 100% ,THE MEAN IS ONLY OVER SUCCESSES .
adversarial re-training [11].
Comparing the exact runtime of attacks can be misleading.
For example, we have parallelized the implementation of
ourL2adversary allowing it to run hundreds of attacks
simultaneously on a GPU, increasing performance from 10
to100. However, we did not parallelize our L0orL1
attacks. Similarly, our implementation of fast gradient sign
is parallelized, but JSMA is not. We therefore refrain from
giving exact performance numbers because we believe an
unfair comparison is worse than no comparison.
All of our attacks, and all previous attacks, are plenty
efÔ¨Åcient to be used by an adversary. No attack takes longer
than a few minutes to run on any given instance.
When compared to L0, our attacks are 2 10slower
than our optimized JSMA algorithm (and signiÔ¨Åcantly faster
than the un-optimized version). Our attacks are typically 10
 100slower than previous attacks for L2andL1, with
exception of iterative gradient sign which we are 10slower.
VIII. E VALUATING DEFENSIVE DISTILLATION
Distillation was initially proposed as an approach to reduce
a large model (the teacher ) down to a smaller distilled model
[19]. At a high level, distillation works by Ô¨Årst training the
teacher model on the training set in a standard manner. Then,
we use the teacher to label each instance in the training set withsoft labels (the output vector from the teacher network). For
example, while the hard label for an image of a hand-written
digit 7will say it is classiÔ¨Åed as a seven, the soft labels might
say it has a 80% chance of being a seven and a 20% chance
of being a one. Then, we train the distilled model on the soft
labels from the teacher, rather than on the hard labels from
the training set. Distillation can potentially increase accuracy
on the test set as well as the rate at which the smaller model
learns to predict the hard labels [19], [30].
Defensive distillation uses distillation in order to increase
the robustness of a neural network, but with two signiÔ¨Åcant
changes. First, both the teacher model and the distilled model
are identical in size ‚Äî defensive distillation does not result
in smaller models. Second, and more importantly, defensive
distillation uses a large distillation temperature (described
below) to force the distilled model to become more conÔ¨Ådent
in its predictions.
Recall that, the softmax function is the last layer of a neural
network. Defensive distillation modiÔ¨Åes the softmax function
to also include a temperature constant T:
softmax (x;T)i=exi=T
P
jexj=T
It is easy to see that softmax (x;T) =softmax (x=T; 1). Intu-
itively, increasing the temperature causes a ‚Äúsofter‚Äù maximum,
and decreasing it causes a ‚Äúharder‚Äù maximum. As the limit
of the temperature goes to 0, softmax approaches max; as
the limit goes to inÔ¨Ånity, softmax (x)approaches a uniform
distribution.
Defensive distillation proceeds in four steps:
1) Train a network, the teacher network, by setting the
temperature of the softmax to Tduring the training
phase.
2) Compute soft labels by apply the teacher network to
each instance in the training set, again evaluating the
softmax at temperature T.
3) Train the distilled network (a network with the same
shape as the teacher network) on the soft labels, using
softmax at temperature T.
124) Finally, when running the distilled network at test time
(to classify new inputs), use temperature 1.
A. Fragility of existing attacks
We brieÔ¨Çy investigate the reason that existing attacks fail
on distilled networks, and Ô¨Ånd that existing attacks are very
fragile and can easily fail to Ô¨Ånd adversarial examples even
when they exist.
L-BFGS and Deepfool fail due to the fact that the gradient
ofF()is zero almost always, which prohibits the use of the
standard objective function.
When we train a distilled network at temperature Tand
then test it at temperature 1, we effectively cause the inputs to
the softmax to become larger by a factor of T. By minimizing
the cross entropy during training, the output of the softmax
is forced to be close to 1:0for the correct class and 0:0for
all others. Since Z()is divided by T, the distilled network
will learn to make the Z()valuesTtimes larger than they
otherwise would be. (Positive values are forced to become
aboutTtimes larger; negative values are multiplied by a
factor of about Tand thus become even more negative.)
Experimentally, we veriÔ¨Åed this fact: the mean value of the
L1norm ofZ()(the logits) on the undistilled network is
5:8with standard deviation 6:4; on the distilled network (with
T= 100 ), the mean is 482with standard deviation 457.
Because the values of Z()are 100 times larger, when
we test at temperature 1, the output of Fbecomesin all
components except for the output class which has conÔ¨Ådence
1 9for some very small (for tasks with 10 classes). In fact,
in most cases, is so small that the 32-bit Ô¨Çoating-point value
is rounded to 0. For similar reasons, the gradient is so small
that it becomes 0when expressed as a 32-bit Ô¨Çoating-point
value.
This causes the L-BFGS minimization procedure to fail to
make progress and terminate. If instead we run L-BFGS with
our stable objective function identiÔ¨Åed earlier, rather than the
objective function loss F;l()suggested by Szegedy et al. [46],
L-BFGS does not fail. An alternate approach to Ô¨Åxing the
attack would be to set
F0(x) =softmax (Z(x)=T)
whereTis the distillation temperature chosen. Then mini-
mizing loss F0;l()will not fail, as now the gradients do not
vanish due to Ô¨Çoating-point arithmetic rounding. This clearly
demonstrates the fragility of using the loss function as the
objective to minimize.
JSMA-F (whereby we mean the attack uses the output of
the Ô¨Ånal layer F()) fails for the same reason that L-BFGS
fails: the output of the Z()layer is very large and so softmax
becomes essentially a hard maximum. This is the version of the
attack that Papernot et al. use to attack defensive distillation
in their paper [39].
JSMA-Z (the attack that uses the logits) fails for a com-
pletely different reason. Recall that in the Z()version ofthe attack, we use the input to the softmax for computing
the gradient instead of the Ô¨Ånal output of the network. This
removes any potential issues with the gradient vanishing,
however this introduces new issues. This version of the attack
is introduced by Papernot et al. [38] but it is not used to attack
distillation; we provide here an analysis of why it fails.
Since this attack uses the Zvalues, it is important to realize
the differences in relative impact. If the smallest input to
the softmax layer is  100, then, after the softmax layer, the
corresponding output becomes practically zero. If this input
changes from 100to 90, the output will still be practically
zero. However, if the largest input to the softmax layer is 10,
and it changes to 0, this will have a massive impact on the
softmax output.
Relating this to parameters used in their attack, and
represent the size of the change at the input to the softmax
layer. It is perhaps surprising that JSMA-Z works on un-
distilled networks, as it treats all changes as being of equal
importance, regardless of how much they change the softmax
output. If changing a single pixel would increase the target
class by 10, but also increase the least likely class by 15, the
attack will not increase that pixel.
Recall that distillation at temperature Tcauses the value of
the logits to be Ttimes larger. In effect, this magniÔ¨Åes the sub-
optimality noted above as logits that are extremely unlikely but
have slight variation can cause the attack to refuse to make
any changes.
Fast Gradient Sign fails at Ô¨Årst for the same reason L-
BFGS fails: the gradients are almost always zero. However,
something interesting happens if we attempt the same division
trick and divide the logits by Tbefore feeding them to the
softmax function: distillation still remains effective [36]. We
are unable to explain this phenomenon.
B. Applying Our Attacks
When we apply our attacks to defensively distilled net-
works, we Ô¨Ånd distillation provides only marginal value. We
re-implement defensive distillation on MNIST and CIFAR-10
as described [39] using the same model we used for our eval-
uation above. We train our distilled model with temperature
T= 100 , the value found to be most effective [39].
Table VI shows our attacks when applied to distillation. All
of the previous attacks fail to Ô¨Ånd adversarial examples. In
contrast, our attack succeeds with 100% success probability
for each of the three distance metrics.
When compared to Table IV, distillation has added almost
no value: our L0andL2attacks perform slightly worse, and
ourL1attack performs approximately equally. All of our
attacks succeed with 100% success.
C. Effect of Temperature
In the original work, increasing the temperature was found
to consistently reduce attack success rate. On MNIST, this
goes from a 91% success rate at T= 1to a24% success rate
forT= 5 and Ô¨Ånally 0:5%success atT= 100 .
13Best Case Average Case Worst Case
MNIST CIFAR MNIST CIFAR MNIST CIFAR
mean prob mean prob mean prob mean prob mean prob mean prob
OurL0 10 100% 7 :4 100% 19 100% 15 100% 36 100% 29 100%
OurL2 1:7 100% 0 :36 100% 2:2 100% 0 :60 100% 2:9 100% 0 :92 100%
OurL1 0:14 100% 0 :002 100% 0:18 100% 0 :023 100% 0:25 100% 0 :038 100%
TABLE VI
COMPARISON OF OUR ATTACKS WHEN APPLIED TO DEFENSIVELY DISTILLED NETWORKS . COMPARE TO TABLE IVFOR UNDISTILLED NETWORKS .
‚óè‚óè‚óè
‚óè‚óè‚óè‚óè‚óè‚óè
‚óè‚óè‚óè‚óè
‚óè‚óè
‚óè‚óè‚óè
‚óè‚óè‚óè
0 20 40 60 80 1000.0 0.5 1.0 1.5 2.0 2.5 3.0
Distillation TemperatureMean Adversarial Distance
Fig. 8. Mean distance to targeted (with random target) adversarial examples
for different distillation temperatures on MNIST. Temperature is uncorrelated
with mean adversarial example distance.
We re-implement this experiment with our improved attacks
to understand how the choice of temperature impacts robust-
ness. We train models with the temperature varied from t= 1
tot= 100 .
When we re-run our implementation of JSMA, we observe
the same effect: attack success rapidly decreases. However,
with our improved L2attack, we see no effect of temperature
on the mean distance to adversarial examples: the correlation
coefÔ¨Åcient is = 0:05. This clearly demonstrates the fact
that increasing the distillation temperature does not increase
the robustness of the neural network, it only causes existing
attacks to fail more often.
D. Transferability
Recent work has shown that an adversarial example for one
model will often transfer to be an adversarial on a different
model, even if they are trained on different sets of training data
[46], [11], and even if they use entirely different algorithms
(i.e., adversarial examples on neural networks transfer to
random forests [37]).
0 10 20 30 400.0 0.2 0.4 0.6 0.8 1.0
Value of kProbability Adversarial Example Transfers, BaselineUntargetted
TargettedFig. 9. Probability that adversarial examples transfer from one model to
another, for both targeted (the adversarial class remains the same) and
untargeted (the image is not the correct class).
Therefore, any defense that is able to provide robust-
ness against adversarial examples must somehow break this
transferability property; otherwise, we could run our attack
algorithm on an easy-to-attack model, and then transfer those
adversarial examples to the hard-to-attack model.
Even though defensive distillation is not robust to our
stronger attacks, we demonstrate a second break of distillation
by transferring attacks from a standard model to a defensively
distilled model.
We accomplish this by Ô¨Ånding high-conÔ¨Ådence adversar-
ial examples , which we deÔ¨Åne as adversarial examples that
are strongly misclassiÔ¨Åed by the original model. Instead of
looking for an adversarial example that just barely changes
the classiÔ¨Åcation from the source to the target, we want one
where the target is much more likely than any other label.
Recall the loss function deÔ¨Åned earlier for L2attacks:
f(x0) = max(maxfZ(x0)i:i6=tg Z(x0)t; ):
The purpose of the parameter is to control the strength of
adversarial examples: the larger , the stronger the classiÔ¨Å-
140 10 20 30 400.0 0.2 0.4 0.6 0.8
Value of kProbability Adversarial Example Transfers, DistilledUntargetted
TargettedFig. 10. Probability that adversarial examples transfer from the baseline model
to a model trained with defensive distillation at temperature 100.
cation of the adversarial example. This allows us to generate
high-conÔ¨Ådence adversarial examples by increasing .
We Ô¨Årst investigate if our hypothesis is true that the stronger
the classiÔ¨Åcation on the Ô¨Årst model, the more likely it will
transfer. We do this by varying from 0to40.
Our baseline experiment uses two models trained on MNIST
as described in Section IV, with each model trained on half of
the training data. We Ô¨Ånd that the transferability success rate
increases linearly from = 0 to= 20 and then plateaus
at near- 100% success for 20, so clearly increasing 
increases the probability of a successful transferable attack.
We then run this same experiment only instead we train
the second model with defensive distillation, and Ô¨Ånd that
adversarial examples dotransfer. This gives us another at-
tack technique for Ô¨Ånding adversarial examples on distilled
networks.
However, interestingly, the transferability success rate be-
tween the unsecured model and the distilled model only
reaches 100% success at= 40 , in comparison to the previous
approach that only required = 20 .
We believe that this approach can be used in general to
evaluate the robustness of defenses, even if the defense is able
to completely block Ô¨Çow of gradients to cause our gradient-
descent based approaches from succeeding.
IX. C ONCLUSION
The existence of adversarial examples limits the areas in
which deep learning can be applied. It is an open problem
to construct defenses that are robust to adversarial examples.
In an attempt to solve this problem, defensive distillation
was proposed as a general-purpose procedure to increase the
robustness of an arbitrary neural network.In this paper, we propose powerful attacks that defeat
defensive distillation, demonstrating that our attacks more
generally can be used to evaluate the efÔ¨Åcacy of potential
defenses. By systematically evaluating many possible attack
approaches, we settle on one that can consistently Ô¨Ånd better
adversarial examples than all existing approaches. We use this
evaluation as the basis of our three L0,L2, andL1attacks.
We encourage those who create defenses to perform the two
evaluation approaches we use in this paper:
Use a powerful attack (such as the ones proposed in this
paper) to evaluate the robustness of the secured model
directly. Since a defense that prevents our L2attack will
prevent our other attacks, defenders should make sure to
establish robustness against the L2distance metric.
Demonstrate that transferability fails by constructing
high-conÔ¨Ådence adversarial examples on a unsecured
model and showing they fail to transfer to the secured
model.
ACKNOWLEDGEMENTS
We would like to thank Nicolas Papernot discussing our
defensive distillation implementation, and the anonymous re-
viewers for their helpful feedback. This work was supported
by Intel through the ISTC for Secure Computing, Qualcomm,
Cisco, the AFOSR under MURI award FA9550-12-1-0040,
and the Hewlett Foundation through the Center for Long-Term
Cybersecurity.
REFERENCES
[1] A NDOR , D., A LBERTI , C., W EISS, D., S EVERYN , A., P RESTA , A.,
GANCHEV , K., P ETROV , S., AND COLLINS , M. Globally normalized
transition-based neural networks. arXiv preprint arXiv:1603.06042
(2016).
[2] B ASTANI , O., I OANNOU , Y., L AMPROPOULOS , L., V YTINIOTIS , D.,
NORI, A., AND CRIMINISI , A. Measuring neural net robustness with
constraints. arXiv preprint arXiv:1605.07262 (2016).
[3] B OJARSKI , M., D ELTESTA , D., D WORAKOWSKI , D., F IRNER , B.,
FLEPP , B., G OYAL , P., J ACKEL , L. D., M ONFORT , M., M ULLER , U.,
ZHANG , J., ET AL . End to end learning for self-driving cars. arXiv
preprint arXiv:1604.07316 (2016).
[4] B OURZAC , K. Bringing big neural networks to
self-driving cars, smartphones, and drones. http:
//spectrum.ieee.org/computing/embedded-systems/
bringing-big-neural-networks-to-selfdriving-cars-smartphones-and-drones,
2016.
[5] C ARLINI , N., M ISHRA , P., V AIDYA , T., Z HANG , Y., S HERR , M.,
SHIELDS , C., W AGNER , D., AND ZHOU , W. Hidden voice commands.
In25th USENIX Security Symposium (USENIX Security 16), Austin, TX
(2016).
[6] C HANDOLA , V., B ANERJEE , A., AND KUMAR , V. Anomaly detection:
A survey. ACM computing surveys (CSUR) 41 , 3 (2009), 15.
[7] C LEVERT , D.-A., U NTERTHINER , T., AND HOCHREITER , S. Fast and
accurate deep network learning by exponential linear units (ELUs).
arXiv preprint arXiv:1511.07289 (2015).
[8] D AHL, G. E., S TOKES , J. W., D ENG, L., AND YU, D. Large-scale
malware classiÔ¨Åcation using random projections and neural networks. In
2013 IEEE International Conference on Acoustics, Speech and Signal
Processing (2013), IEEE, pp. 3422‚Äì3426.
[9] D ENG, J., D ONG , W., S OCHER , R., L I, L.-J., L I, K., AND FEI-FEI,
L. Imagenet: A large-scale hierarchical image database. In Computer
Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference
on(2009), IEEE, pp. 248‚Äì255.
15[10] G IUSTI , A., G UZZI , J., C IRES¬∏AN, D. C., H E, F.-L., R ODR¬¥IGUEZ ,
J. P., F ONTANA , F., F AESSLER , M., F ORSTER , C., S CHMIDHUBER , J.,
DICARO, G., ET AL . A machine learning approach to visual perception
of forest trails for mobile robots. IEEE Robotics and Automation Letters
1, 2 (2016), 661‚Äì667.
[11] G OODFELLOW , I. J., S HLENS , J., AND SZEGEDY , C. Explaining
and harnessing adversarial examples. arXiv preprint arXiv:1412.6572
(2014).
[12] G RAHAM , B. Fractional max-pooling. arXiv preprint arXiv:1412.6071
(2014).
[13] G RAVES , A., M OHAMED , A.- R.,AND HINTON , G. Speech recognition
with deep recurrent neural networks. In 2013 IEEE international
conference on acoustics, speech and signal processing (2013), IEEE,
pp. 6645‚Äì6649.
[14] G ROSSE , K., P APERNOT , N., M ANOHARAN , P., B ACKES , M., AND
MCDANIEL , P. Adversarial perturbations against deep neural networks
for malware classiÔ¨Åcation. arXiv preprint arXiv:1606.04435 (2016).
[15] G U, S., AND RIGAZIO , L. Towards deep neural network architectures
robust to adversarial examples. arXiv preprint arXiv:1412.5068 (2014).
[16] H E, K., Z HANG , X., R EN, S., AND SUN, J. Deep residual learning for
image recognition. In Proceedings of the IEEE Conference on Computer
Vision and Pattern Recognition (2016), pp. 770‚Äì778.
[17] H INTON , G., D ENG, L., Y U, D., D AHL, G., RAHMAN MOHAMED , A.,
JAITLY , N., S ENIOR , A., V ANHOUCKE , V., N GUYEN , P., S AINATH , T.,
AND KINGSBURY , B. Deep neural networks for acoustic modeling in
speech recognition. Signal Processing Magazine (2012).
[18] H INTON , G., D ENG, L., Y U, D., D AHL, G. E., M OHAMED , A.- R.,
JAITLY , N., S ENIOR , A., V ANHOUCKE , V., N GUYEN , P., S AINATH ,
T. N., ET AL . Deep neural networks for acoustic modeling in speech
recognition: The shared views of four research groups. IEEE Signal
Processing Magazine 29 , 6 (2012), 82‚Äì97.
[19] H INTON , G., V INYALS , O., AND DEAN, J. Distilling the knowledge in
a neural network. arXiv preprint arXiv:1503.02531 (2015).
[20] H UANG , R., X U, B., S CHUURMANS , D., AND SZEPESV ¬¥ARI, C. Learn-
ing with a strong adversary. CoRR, abs/1511.03034 (2015).
[21] H UANG , X., K WIATKOWSKA , M., W ANG , S., AND WU, M. Safety
veriÔ¨Åcation of deep neural networks. arXiv preprint arXiv:1610.06940
(2016).
[22] J ANGLOV ¬¥A, D. Neural networks in mobile robot motion. Cutting Edge
Robotics 1 , 1 (2005), 243.
[23] K INGMA , D., AND BA, J. Adam: A method for stochastic optimization.
arXiv preprint arXiv:1412.6980 (2014).
[24] K RIZHEVSKY , A., AND HINTON , G. Learning multiple layers of
features from tiny images.
[25] K RIZHEVSKY , A., S UTSKEVER , I., AND HINTON , G. E. ImageNet
classiÔ¨Åcation with deep convolutional neural networks. In Advances
in neural information processing systems (2012), pp. 1097‚Äì1105.
[26] K URAKIN , A., G OODFELLOW , I., AND BENGIO , S. Adversarial exam-
ples in the physical world. arXiv preprint arXiv:1607.02533 (2016).
[27] L ECUN, Y., B OTTOU , L., B ENGIO , Y., AND HAFFNER , P. Gradient-
based learning applied to document recognition. Proceedings of the
IEEE 86 , 11 (1998), 2278‚Äì2324.
[28] L ECUN, Y., C ORTES , C., AND BURGES , C. J. The mnist database of
handwritten digits, 1998.
[29] M AAS, A. L., H ANNUN , A. Y., AND NG, A. Y. RectiÔ¨Åer nonlinearities
improve neural network acoustic models. In Proc. ICML (2013), vol. 30.
[30] M ELICHER , W., U R, B., S EGRETI , S. M., K OMANDURI , S., B AUER ,
L., C HRISTIN , N., AND CRANOR , L. F. Fast, lean and accurate:
Modeling password guessability using neural networks. In Proceedings
of USENIX Security (2016).
[31] M ISHKIN , D., AND MATAS , J. All you need is a good init. arXiv
preprint arXiv:1511.06422 (2015).[32] M NIH, V., K AVUKCUOGLU , K., S ILVER , D., G RAVES , A.,
ANTONOGLOU , I., W IERSTRA , D., AND RIEDMILLER , M. Playing
Atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602
(2013).
[33] M NIH, V., K AVUKCUOGLU , K., S ILVER , D., R USU, A. A., V ENESS ,
J., B ELLEMARE , M. G., G RAVES , A., R IEDMILLER , M., F IDJELAND ,
A. K., O STROVSKI , G., ET AL . Human-level control through deep
reinforcement learning. Nature 518 , 7540 (2015), 529‚Äì533.
[34] M OOSAVI -DEZFOOLI , S.-M., F AWZI , A., AND FROSSARD , P. Deep-
fool: a simple and accurate method to fool deep neural networks. arXiv
preprint arXiv:1511.04599 (2015).
[35] P APERNOT , N., G OODFELLOW , I., S HEATSLEY , R., F EINMAN , R., AND
MCDANIEL , P. cleverhans v1.0.0: an adversarial machine learning
library. arXiv preprint arXiv:1610.00768 (2016).
[36] P APERNOT , N., AND MCDANIEL , P. On the effectiveness of defensive
distillation. arXiv preprint arXiv:1607.05113 (2016).
[37] P APERNOT , N., M CDANIEL , P., AND GOODFELLOW , I. Transferabil-
ity in machine learning: from phenomena to black-box attacks using
adversarial samples. arXiv preprint arXiv:1605.07277 (2016).
[38] P APERNOT , N., M CDANIEL , P., J HA, S., F REDRIKSON , M., C ELIK ,
Z. B., AND SWAMI , A. The limitations of deep learning in adversarial
settings. In 2016 IEEE European Symposium on Security and Privacy
(EuroS&P) (2016), IEEE, pp. 372‚Äì387.
[39] P APERNOT , N., M CDANIEL , P., W U, X., J HA, S., AND SWAMI , A.
Distillation as a defense to adversarial perturbations against deep neural
networks. IEEE Symposium on Security and Privacy (2016).
[40] P ASCANU , R., S TOKES , J. W., S ANOSSIAN , H., M ARINESCU , M.,
AND THOMAS , A. Malware classiÔ¨Åcation with recurrent networks. In
2015 IEEE International Conference on Acoustics, Speech and Signal
Processing (ICASSP) (2015), IEEE, pp. 1916‚Äì1920.
[41] R USSAKOVSKY , O., D ENG, J., S U, H., K RAUSE , J., S ATHEESH , S.,
MA, S., H UANG , Z., K ARPATHY , A., K HOSLA , A., B ERNSTEIN , M.,
BERG, A. C., AND FEI-FEI, L. ImageNet Large Scale Visual Recogni-
tion Challenge. International Journal of Computer Vision (IJCV) 115 ,
3 (2015), 211‚Äì252.
[42] S HAHAM , U., Y AMADA , Y., AND NEGAHBAN , S. Understanding
adversarial training: Increasing local stability of neural nets through
robust optimization. arXiv preprint arXiv:1511.05432 (2015).
[43] S ILVER , D., H UANG , A., M ADDISON , C. J., G UEZ, A., S IFRE , L.,
VANDENDRIESSCHE , G., S CHRITTWIESER , J., A NTONOGLOU , I.,
PANNEERSHELVAM , V., L ANCTOT , M., ET AL . Mastering the game
of Go with deep neural networks and tree search. Nature 529 , 7587
(2016), 484‚Äì489.
[44] S PRINGENBERG , J. T., D OSOVITSKIY , A., B ROX, T., AND RIED-
MILLER , M. Striving for simplicity: The all convolutional net. arXiv
preprint arXiv:1412.6806 (2014).
[45] S ZEGEDY , C., V ANHOUCKE , V., I OFFE , S., S HLENS , J., AND WOJNA ,
Z. Rethinking the Inception architecture for computer vision. arXiv
preprint arXiv:1512.00567 (2015).
[46] S ZEGEDY , C., Z AREMBA , W., S UTSKEVER , I., B RUNA , J., E RHAN ,
D., G OODFELLOW , I., AND FERGUS , R. Intriguing properties of neural
networks. ICLR (2013).
[47] W ARDE -FARLEY , D., AND GOODFELLOW , I. Adversarial perturbations
of deep neural networks. Advanced Structured Prediction, T. Hazan, G.
Papandreou, and D. Tarlow, Eds (2016).
[48] Y UAN, Z., L U, Y., W ANG , Z., AND XUE, Y. Droid-sec: Deep learning
in android malware detection. In ACM SIGCOMM Computer Commu-
nication Review (2014), vol. 44, ACM, pp. 371‚Äì372.
APPENDIX
16Target ClassiÔ¨Åcation ( L0)
0 1 2 3 4 5 6 7 8 9Source ClassiÔ¨Åcation
0 1 2 3 4 5 6 7 8 9
Fig. 11. Our L0adversary applied to the CIFAR dataset performing a targeted attack for every source/target pair. Each image is the Ô¨Årst image in the dataset
with that label.
17Target ClassiÔ¨Åcation ( L2)
0 1 2 3 4 5 6 7 8 9Source ClassiÔ¨Åcation
0 1 2 3 4 5 6 7 8 9
Fig. 12. Our L2adversary applied to the CIFAR dataset performing a targeted attack for every source/target pair. Each image is the Ô¨Årst image in the dataset
with that label.
18Target ClassiÔ¨Åcation ( L1)
0 1 2 3 4 5 6 7 8 9Source ClassiÔ¨Åcation
0 1 2 3 4 5 6 7 8 9
Fig. 13. Our L1adversary applied to the CIFAR dataset performing a targeted attack for every source/target pair. Each image is the Ô¨Årst image in the dataset
with that label.
19